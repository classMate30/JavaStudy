/*=============================================
 	■■■클래스 고급■■■
 	- 상속 관계에 있는 클래스들 간의 캐스팅
 	  (업 캐스팅, 다운 캐스팅)
 =============================================*/

// super class, 부모클래스, 상위 클래스
class SuperTest116
{
	public int a = 10, b =20;
	
	public void write()
	{
		System.out.println("슈퍼 클래스 write() 메소드...");
		
	}
	
	public int hap()
	{
		return a+ b;
	}
}

// sub class, 자식 클래스, 하위 클래스
class SubTest116 extends SuperTest116
{
	public int b = 100, c= 200;
	
	@Override
	public int hap()
	{
		return a + b + c;
	}
	public void print()
	{
		System.out.println("서브 클래스 print() 메소드…");
	}
}

//main() 메소드를 포함하는 외부의 다른 클래스
public class Test116
{
	public static void main(String[] args)
	{	

		// sub class(하위 클래스) 기반 인스턴스 생성
		SubTest116 ob1 = new SubTest116();

		System.out.println("ob1.b : "  +ob1.b);
		//--==>>ob1.b : 100
		
		// ○ 업캐스팅
		//SuperTest116 ob2;
		SuperTest116 ob2 = ob1;
		//SuperTest116 ob2 = new SubTest116();
		//-- 『SuperTest116 ob2 = (SuperTest116)ob1』과 동일한 코드

		/*

		학생 소연이 = new 학생();

		포유류 사람 = 소연이;    //『포유류 사람 = (사람)소연이;』과 동일한 코드

		
		※학생도 포유류

		※class 포유류			class 학생 extends 포유류
		  {						{
		  }						}
		
		비교)
		byte a = 10;
		
		int b =a;				//『int b = (int)a;』와 동일한 코드
		
		*/

		System.out.println("ob2.b : " + ob2.b);
		//--==>>ob2.b : 20
		//-- 변수는 객체별로 따로 할당되기 때문에
		//	 변수 b는 ob2의 변수다

		System.out.println("합    : " + ob2.hap());
		//--==>>합    : 310
		//--hap() 메소드는 오버라이딩(Overriding)되어 있고
		//	ob2는 ob1을 업캐스팅한 상태의 객체이므로 
		//	『SuperTest116』의 hap() 메소드를 호출하는 것이 아니라
		//	『SuperTest116』에서 재정의한 hap()메소드를 호출하게 된다.
		//	즉, 메소드는 업캐스팅 되더라도
		//	재정의(덮어쓰기) 한 이상... 원래의 기능으로 되돌릴 수 없다

		ob2.write();
		//ob2.print();
		//--==>> 에러 발생(컴파일 에러)
		
		//○다운 캐스팅
		((SubTest116)ob2).print();
		//--==>> 서브 클래스 print() 메소드…
		/*
		 자식클래스로써 부모와 자식의 정보를 둘다가진 
		 ob1을 부모클래스로 격상시켜서 만든게 ob2니까 

		 ob2에는 부모와 자식의 정보가 둘다 들어있으니까
		 자식클래스로의 다운도 가능하다는 말씀

		*/
		//자식클래스의 인스턴스 생성 구문은
		//부모클래스를 메모리에 먼저 올림
		//그러니까 자식클래스의 인스턴스 생성이 되면, 
		//부모클래스 + 자식클래스 메모리

		// ※ 추가 관찰 -----------------------------
		//	  다운 캐스팅 가능 여부
		
		SuperTest116 ob3 = new SuperTest116();
		SubTest116 ob4;		//아직 메모리에 퍼올려지지 않음 위의 구문은 자손을 생성할때 퍼올려짐

			
		//System.out.println(ob3.c);
		//--==>> 에러 발생(컴파일 에러)
		//-- 상위 객체는 하위 객체의 멤버에 접근하는 것이 불가능하다
		//	 (상위 객체 입장에서는 어떤 하위 객체가 존재하는지도 알 수 없음)
		

		//ob4 = (SubTest116)ob3;
		//--==>> 에러 발생(런타임 에러)
		//-- 상위 객체는 하위 객체에 담을(참조할 수) 없다.
		//-- 작성된 구문의 문법적인 구조만 봤을때
		//	 다운 캐스팅이 이루어지는 상황이다
		//	 하지만, 정상적인 캐스팅이 이루어지지 않는다
		//	 현재 SubTest116 객체에 대해 메모리 할당이 이루어지지 않은 상태이기 때문에
		//	 다운 캐스팅은 불가능한 것이다



	}
}


/*
○ 업 캐스팅, 다운 캐스팅이 정상적으로 이루어지는 경우 ------------------------------
	
	1. 하위 객체 생성;		//★핵심★ check~!! ★생성된 객체가 하위 객체다★
	2. 상위 = 하위;			//업캐스팅 (정상)
	//(錯誤) 하위 = 상위;	//에러 발생
	3. 하위 = (하위)상위;	//다운캐스팅 (정상)


○ 다운 캐스팅이 정상적으로 이루어지지 않는 경우------------------------------------
	
	1. 상위 객체 생성;
	2. 하위 = 상위;		 //에러 발생
	3. 하위 = (하위)상위 // 다운캐스팅(런타임 에러 발생)

※ 업 캐스팅은 항상 가능 ,  다운 캐스팅은 경우에 따라 가능 여부 갈림


*/
