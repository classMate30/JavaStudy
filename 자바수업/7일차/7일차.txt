※Test029 System.in.read()사용하고 / BufferedReader와 Scanner사용하지 않았던 이유

우리가 구해야 할 것은 문자 하나를 입력 받아서 처리한다고 직관적으로 명시 돼있어 바로 System.in.read();로 시작했지만,
System.in.read 와 BufferedReader / Scanner는 중요한 차이점이 있음 → 그렇기에 System.in.read()로 처리한 것임.

□BufferedReader/Scanner는 값을 ★"문자열"★의 형태로 얻어오고,
  System.in.read는 값을 4바이트 ★정수형★으로 얻어온다.

	BufferedReader / Scanner 문자열로 읽어옴
	BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
								   										  ----------
																			Byte기반
					 	  							-------------------
													Byte기반을 문자열로 번역
								----------------
								입력하는 것을 가져옴(이 개념은 추후 자세하게 배울 것)

□그렇기에 우리가 한문자만 넘겨도 사실 BufferedReader는  ex) "A" 이런식으로 문자열로 가져오는 것임
  우리눈엔 입력한 값이 똑같은 A여도 컴퓨터안에서는 "A"와 'A'의 "문자열"과 '문자'의 차이를 가지기에 엄연히 다른것 

ex) year = Integer.parseInt(br.readLine());		//이렇게 가져온 "문자열 형태의 숫자" 를 숫자로 만드는 것임
		    										 	//만약 입력값이 "2012"였으면 이게 이 과정을 거쳐 2012가 되는 것임
											 		   //우리가 지금쓰는 Integer.parseInt의 핵심은 "문자열 형태의 숫자"

□Test029에서 『대문자를 소문자로』,『소문자를 대문자로』이렇게 바꾸는데 핵심은 true / false로 판단하여 비교를 한 후
  바꿔줘야하는데 문자열로는 크기 비교하는 법을 배우지 않음(이런 방법이 있는지 나중에 배우는지는 모르겠음)


□그러므로 값에대한 크기비교를 하려면
  정수형태로 아스키코드 값을 가져오는 System.in.read()로 진행해야함



※Test029 작성 시 생각했던 흐름 (feat.『대문자를 소문자로』,『소문자를 대문자로』,『알파벳이 아닌 문자 그대로』)

1.임의의 ★문자★(문자열 아님)를 받아올 건데,
  System.in.read() 문자를 정수형으로 바로 가져옴
  받아온 값을 (char)타입으로 형변환 해서 char타입의 변수 ch에 저장함


2. 두개 이상의 조건이 등장했다면 무조건 논리연산자를 사용한다!
ex)30<= a <=40    
   30<=a         →30 <=a && a<=40
        a<=40
   이런식으로 받아온 문자가 대문자인지 소문자인지 그것도 아니면 다른 문자인지 비교를 해줄 수 있게 범위를 설정
ex) (ch >= 'A' && ch <= 'Z') 대문자의 범위인 것 
	 (ch >= 'a' && ch <= 'z') 소문자의 범위인 것 // 이 둘의 범위에 없다면 대문자도 소문자도 아닌 것임


3. 조건 연산자(삼항 연산자)를 통해 받아온 문자를 변환 하는 과정 거칠 것임
  ex) (입력값대문자) ? (소문자로 변환) : ((입력값소문자? 대문자로 변환 : 그대로반환));
  → 입력값이 대문자이면 소문자로 변환하고, 입력값이 소문자이면 대문자로 변환하고, 그것도 아니면 그대로 반환해라!

4.	연산(인트 기반)을 거쳐서 『대문자를 소문자로』,『소문자를 대문자로』고쳐줄 과정을 그림
		// 대문자 → 소문자						소문자		→		대문자 
		// 'A'(65) → 'a'(97) ==> +32			'a'(97)	→		'A'(65)	==> -32
		// 'B'(66) → 'b'(98) ==> +32			'b'(98) 	→ 		'B'(66)	==> -32 
		// 'C'(67) → 'c'(99) ==> +32			'c'(99)	→		'C'(67)	==> -32
		//			:											:
5. result = (ch >= 'A' && ch <= 'Z') ? ((char)(ch+32)) : ((ch >= 'a' && ch <= 'z') ? (char)(ch-32) :ch);
	연산으로 대문자는 소문자로, 소문자는 대문자로, 둘다 아니면 그대로 반환할 건데 그 문자를 char타입의 result에 저장
	※주의 : (ch+32)는 인트형 기반의 연산이며 결과값을 int로 가지기에 (char)타입으로 형변환 해서 반환하는 것

6. 그대로 출력하면 완료


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
temp (char)System.in.read
문자 (문자)(숫자)
'A' >=  65
캐릭	인트
인트로변환됨

temp >= 65 && temp <=90 ?
true && temp <=90 ?
true && true

temp >= 65 && temp <=90 ? "대문자" : "대문자아님";
"대문자"

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
		//String result = temp >= 65 && temp <=90 ? "대문자" : "대문자아님";
		//System.out.println("결과 : "+ result);

==
		//String result temp >= 'A' && temp <= 'Z' ? "대문자" : "대문자아님";
		//System.out.println("결과 : " + result);
		// 연산할때 인트형으로 바뀌는 것임 

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

논리연산 그림
		// 교집합 and
		// 모두 필요하면 or
