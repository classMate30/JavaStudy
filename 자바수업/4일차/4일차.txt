6월30일 수업(실습 전까지)

형 변환 : 데이터 타입이 맞게끔 변환하게 하는 것
	
Byte → Short
  1       2 	↘ 
					int→ long → float → double  ※long보다 float의 표현범위가 더 넓음.
		 		↗	 4     8        4        8 
         char 
			2
형 변환 ┌1. 자동 형 변환(묵시적 형 변환)
        │ □  byte 5 + int 10
        │     →int 5 + int 10
        │   
        │     byte 5 + short 10 
        │     →short 5 + short 10
        │ 
        │  연산시 작은 그릇에 담겨 있는 것은 큰 그릇으로 자바가 자동으로 바꿔줌.  
        │  
        │ □long형은 8바이트고 float은 4바이트지만, float이 표현 할 수 있는 범위가 더 넓음
        │  그러므로 long에서 float으로 형 변환이 일어나는 것.
        │ 
        │ □ 'A' + 10 = 75  A는 컴퓨터에서 00000000 01000001 으로 저장, 65임
        │ 
        │ 
        └2. 강제 형 변환 (명시적 형 변환)
           ①자동 형변환 규칙에 위배되지만, 변환 해야 할 때   
             long a = 10;  //10은 int로 준비하지만 int->long으로 자동형변환 가능하니 담긴다.
             byte b = (byte)a; //바이트에 담길 수 없고, 10은 바이트 타입으로 담기니 강제적으로 형변환
           ②의도한 것이라는 것을 알려줄 때             
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

정수형 상수 int형으로 표현
실수형 상수 double형으로 표현
자바는 10을 준비하면 int형으로 준비함
       3.14를 준비하면 double로 준비함

int num=10000000000; //에러 int는 ±21억만 담을 수 있음
long num=10000000000; //에러 (오른편)4바이트의 메모리를 준비하지만, 8바이트 메모리확보 해야함 
long num=10000000000L; //Ok 자바야 이번만큼은 long형 메모리를 준비해줘! 난 변수 long형에 넣을거야

float pi=3.14; //에러 (오른쪽)3.14는 8바이트 double로 준비함 근데 왼쪽은 float임
float     double     // 자동 형변환 규칙에 맞지않음 ,위에 화살표 보면 float->double
       ▼
float pi=3.14f; //뒤에, 이번엔 double말고 float으로 준비해줘 라고 쪽지 보낸 [접미사]f


float pi=0; // 가능! 오른쪽 int타입으로 준비된 0은 float타입으로 들어갈 수 있음
float pi=0.0;//에러! 오른쪽 double타입으로 준비된 0.0은 float타입으로 들어갈 수 없음

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
연산자
=
* / % + -

★복합대입 연산자 기억법★
a += b a를 b만큼 증가시켜라
a -= b a를 b만큼 감소시켜라
a *= b a를 b만큼 곱해라
a /= b a를 b로 나눠라
a %= b a를 b로 나눈 나머지를 얻어내라

관계 연산자
<    >    <=    >=    ==     !=
모든 관계 연산자의 결과는 true 또는 false이다


논리 연산자
&& 논리and  모두 다 참이여야 참
|| 논리or   어느 하나라도 참이기만 하면 참
!  논리not  부정

자바에서는 ;은 종결자의 의미로 쓰인다.
『+』 연산에 하나라도 문자열이 있다면 문자열 결합 연산으로 쓰인다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

단항 연산자
①부호 + -
  단항연산자 -는 부호를 바꾸는 역할(양수를 음수로 바꾸는 역할이라고 설명하면 x)
② 증감연산자 (++  --)                       (** // 이런애들은 없음,//은 주석임)
   ++ 증가연산자(1만큼 증가시켜라)     -- 감소연산자(1만큼 감소시켜라)
ex)a++ (a를 1만큼 증가시켜라) a--(a를 1만큼 감소시켜라)

   ★★증감연산자는 앞에 붙어있느냐,뒤에 붙어있느냐에 따라 의미가 다르다★★ 
	++a(prefix)										--a(prefix)
  →a를 1만큼 증가시켜라 (지금당장)		  		 a를 1만큼 감소시켜라 (지금당장)


	a++(postfix)							 	 		 a--(postfix)
  →a를 1만큼 증가시켜라 (다음 처리에서...) 	 	a를 1만큼 감소시켜라 (다음 처리에서...)
												 
		int num1 = 7;							 |			int num1 = 7; 
		int num2, num3;		prefix			 |			int num2, num3;     postfix
												 |
		num2 = ++num1;							 |			num2 = num1++;
		num3 = --num1;							 |			num3 = num1--;
※출력시 num1:7 num2:8 num3:7					 |		num1:7 num2:7 num3:8
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
비트 단위 연산자 / 비트 연산자 (비트와 관련있는 연산자)

비트 단위 연산자는 다른 연산자들에 비해 연산 처리 속도가 매우 빠르다.
그 중 비트shift연산자의 연산 속도는 타의 추종을 불허한다.
경력에 따라 비트 단위 연산자의 활용도가 높아짐

& [비트 and]
| [비트 or ]
~ [비트 not (부정)]
^ [비트 xor 피연산자 둘이 같으면0 , 둘이 서로 다르면 1]


비트 shift 연산자
:비트열을 이동시키는 연산
(부등호로 보지말고 화살표로 봐야 이해가 편함)
『<<』	  『>>』  	『>>>』

10 << 2		빈칸을 0으로 채움
00001010
00101000

10 >>> 3		빈칸을 0으로 채움
0001010
0000001


>> 양수일때와 음수일때가 다르다
양수 >>  빈칸을 0으로 채움
음수 >>  빈칸을 1으로 채움


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ


