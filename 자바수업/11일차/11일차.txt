6장[메소드와 변수의 스코프]
■메소드
□메소드에 대한 이해
메소드는 곧 함수, 그러나 반드시 클래스 안에 있어야함

※main메소드
이름을 내맘대로 바꿀수 없다
메소드 중괄호 내에 존재하는 문장들이 위→아래로 순차적 실행
why항상 메인일까? 프로그램이 실행 시 인터프리터가 제일 먼저 찾음
메인메소드의 시작 프로그램의 시작, 메인메소드의 끝은 프로그램의 끝


메소드 형태 :이름()
매개변수 = 메소드가 필요한 걸 전달해주는 영역

ex)
행위/기능/동작(넘겨줘야 하는것)		//괄호안이 매개변수
hiEveryone(int age)		
사과판매(사과)
피아노옮겨주는기능메소드(피아노)

매개변수는 하나,많이,없음 가능

매개변수 영역 e(int age, int height)


메소드끼리의 위치는 상관x	어디있든 인터프리터는 메인부터 찾음
main		hiEveryone
hiEveryone	main

메소드의 정의
메소드의 실행(호출)
hiEveryone(12) 호출 ,잠깐와서 실행하고감,버튼을 누르면(호출하면) 기능 수행후 돌아감
		     사용 마다 호출해야함(띵동을 누르면 호출되고 일하면 돌아감 또 필요하면 또 호출)
public static void hiEveryone(int age)
{
	System.out.println("좋은 아침입니다.");
	System.out.println("제 나이는"+age+"세입니다.");
}


void)매개변수2개 ,0개 예제
ex)
public static void main(String[] args)
{
	double myHeight=179.5;
	hiEveryone(12, 12.5);	
	hiEveryone(13, myHeight); ←★가능  //이름이 키티여도 작업하는 사람끼린 필요하다면 이눔시끼도 가능	
	byeEveryone();

}
public static void hiEveryone(int age, double height)
{
	System.out.println("좋은 아침입니다.");
	System.out.println("제 나이는"+age+"세입니다.");
	System.out.println("제 키는"+height+"cm입니다.");
}

public static void byeEveryone() ←★전달되는 것 없음, 넘겨주는 것 없이 일시켜야함★
{
	System.out.println("다음에 뵙겠습니다.");
}



※값을 반환하는 메소드
반환자료형 명시
→남겨두는것 메소드()	//
int hiEveryone		//공간을 확보함(메소드를 부르는 곳에선 적어도 알고 불러라)
double hiEveryone	//냉장고를 가져오려는데 냉장고 놓을 공간이 없으면 어떻게 가져옴?
			//아아를 한컵만큼 부어주려는데 선생님한테 담아놓을 컵이나 사발이나 아무것도 없으면 손에 쏟고가버릴수있음

main()
{
	int temp=sum(10,20);	//값을 반환하는 것을 담아둘 것을 준비해야함
	System.out.println(temp);
}
반환자료형
▼
int sum(int num1, int num2)
{
	int result=0;
	result = num1 +num2;
	return result;	//1.값의 반환2.메소드 종료
}

※아무것도 두고가지 않는 메소드가있음
특정한 값을 반환하지 않을때는 void를 붙이기로 함

1.문법적인 선점으로 인해 아무것도 안쓸수가 없었음
 

■변수의 스코프
스코프, 생명 주기, life cycle, 가시성
선언된 지역을 벗어나면 변수는 자동 소멸된다(가비지 컬랙터가 어딜 지나느냐에따라 다르지만 이렇게 봐도 무방)
if에서 선언된 num변수는 else에서는 안보인다


■메소드의 재귀호출(다시 돌아가게끔 호출)
자료구조 알고리즘
두번째 벽 재귀

팩토리얼을 이용해서 이해하면
n! = n x (n-1)!
그런데 1! = 1 1! =1x(0!) (x)



f(n) = n * f(n-1)
	1

public static int factorial(int n)
{
	if(n==1)
		return 1;
	else 
		return n * factorial(n-1);

}
코드를 복사해서 실행하는 형식!


★★★★★★★★★★★★7장[클래스와 인스턴스]★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
객체지향은 한문장으로 일목요연하게 정의가 안되며 반복작업을 통해 개념의 이해도를 확장시켜야함
오늘은 객체지향에서 중요한 클래스와 인스턴스부터 시작할 것 

객체지향 프로그래밍 기법
(객체중심 프로그래밍 기법)

객체지향 프로그래밍 언어
(객체중심 프로그래밍 언어)
--------

객체란 무엇인가???????????    ※주체 vs 객체의 객체아님, 객체는 이렇게 좁은범위가 아님
=====
Object(객체)
현실에 존재하는 모든 것             

≒ 존재하는 모든것의 관계를 통해 프로그래밍을 해나가는 구조

			      속성(상태값:보드마커의 질량,무게,재질,잉크,색상,미세먼지...)(일단 필요한거 갖다쓸예정)
				↓ 기능(행위,속성의 값을 다르게 만듬) (보드마커의 뚜껑을 여는 행위, 뚜껑을 닫는행위...)
				↓   ↓
객체의 설계도를 구성 하는 것: 속성 기능
       클래스를 구성 하는 것: 변수 메소드
      (설계도,붕어빵기계틀 등으로 표현되기도함)


절차 지향....

함수 지향....

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
클래스 정의와 인스턴스생성


객체
과일장수 과일 판매(행위)를 통해 사과20 오렌10개보유 판매수익50000(상태) 변하게된다

클래스는 붕어빵 기계틀처럼 설계도 라고 불리운다.
클래스 라는 설계도를 통해 우리는 객체를 생성 할 수 있다.

클래스 → 설계
객체   → 생성(인스턴스 생성)
★★★설계도만 있어선 안됨 설계도를 기반으로 객체를 생성해야함★★★
★★★메모리에 퍼올려줘야 『실체화』 된 것(인스턴스생성)★★★

FruitSeller fs1= new FruitSeller();			ex)역삼역 과일장수
FruitSeller fs2= new FruitSeller();			ex)홍대입구역 과일장수
같은 설계도를 사용해서 만들어도 다른객체(인스턴스) 존재 가능 

같은 설계도를 사용해서 만들지만, 다른 설정 값을 주고 싶음.
ex)같은 기계틀로 만든 붕어빵 같이  더욱 더 바삭하게 만들고 싶을 수도 있고 ,팥을 추가 하고 싶을 수 있음
(1200 10 0)
		↓
FruitSeller fs1= new FruitSeller();        
fs1.세팅(1500, 40, 50000);

		↓
생성 동시에 초기화 FruitSeller fs1= new FruitSeller(1500, 40, 50000);  == 생성자??????
new FruitSeller = 클래스를 메모리에 퍼올려줘라
  

		
★★★//생.성.자  → 메소드★★★
FruitSeller(가격, 갯수, 돈)   // 클래스 이름과 똑같음
{
  특징//인스턴스 생성시 생성자 딱 한번만 호출됨, 
      //final변수도 초기화가능 특권있음
}

new BufferedReader   //메모리에 퍼올려줘
BufferedReader();//생성자 생성
new BufferedReader();//인스턴스 생성

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
FruitSeller fs1= new FruitSeller(1500, 40, 50000);			ex)역삼역 과일장수
FruitSeller fs2= new FruitSeller(1200, 10, 10000);			ex)홍대입구역 과일장수

public void buyApple(FruitSeller seller,int money)
                     ------------------
			어떤 사과 장수인지?

FruitSeller 유동현= new FruitSeller(1500, 40, 50000);			ex)역삼역 과일장수
FruitSeller 최동현= new FruitSeller(1200, 10, 10000);


FruitSeller 최나윤= new FruitSeller();
최나윤.buyApple(유동현,3000);


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
참조변수:주소를 가리키는

int n =10;n값
FruitSeller seller = new FruitSeller();seller주소
1.클래스(설계도)메모리에 퍼올린다. 2.생성자(메소드)를 호출한다 3. 실제로 사용할수 있는 클래스인 참조변수를 이름으로 가지는 객체 생성

br.readLine();

sc.next();

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

8장[클래스 패스]
9장[접근제어자]