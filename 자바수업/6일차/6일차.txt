


//입력 대기열에 남아있는 『\r』과『\n』을 스킵해줘야 한다.(건너뛰기)
								↓
한 문자 입력          : B
한 자리 정수 입력     : 5

입력한 문자 : B
입력한 정수 : 53
계속하려면 아무 키나 누르십시오 . . .

정수를 5를 입력했는데 53이 나옴
아스키코드 값을 가져옴 


해결 방법
1.임시 변수 temp활용
2.n -= 48 
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
BufferedReader br= new BufferedReader 문자 기반

System.in 바이트 기반
문자와 바이트, 기반이 다르므로 번역기 InputStreamReader을 사용했었음


Scanner는 번역기가 필요없음. 그렇다면 왜 BufferedReader씀? 스캐너가 훨씬좋은데
★개발 환경에선 기능이 많다고 성능이 좋은 것이 아님★
CPU가 많은 일을 하는 것 같지만 실제로는 일을 하나 밖에 못함
다만 일을 겁나 빨리 하기때문에 우리가 그렇게 느끼는 것일 뿐
그렇기에 보통은 기능이 더 많다는 것은 성능이 더 안 좋다는 것을 의미.
상황에 맞춰 사용할 것
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
사용자의 입력을 받아오는 방법 중 우리가 배운것.
1.BufferedReader
2.System.in.read(); 문자 하나만 읽어왔던 방식
3.System.util.Scanner  //키보드보다 조금 향상된 형태라고 보면 됨. BufferedReader를 살짝 개선한 입력장치

오늘은 Scanner를 세가지 형태로 진행
1.BufferedReader처럼 (Test017)

2. (공백 구분)한번에 처리 하는 형식 (Test018)

3. ,를 구분하는 형식으로 사용하기(Test019)
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
① Scanner sc;라고 선언하고싶음
import java.util.Scanner;
ex)기본primitive 변수(java가 어떻게 만들어줘야하는지 앎) 제외하고는
java한테 PlayGame pg;를 만들건데 그 설계도가 어딨는지 알려줘야함. -> ex)import aaa.bbb.playGame;
설계도를 너가 본 후에 메모리를 너가 구성해!

② Scanner sc = new Scanner()
인트 타입은 int a=7; , 캐릭터타입은 char ch1= 'A'이런식으로 담는데,
Scanner라는 타입은 기본과 다르게 정해진게 없기에 새롭게 메모리에(new) 퍼올려줘야함

※new Scanner()의 ()는 왜붙었나?
우리는 이름()이런 형식은 99.9% 메소드라고 배웠음

new Scanner()
new Scanner
    Scanner() 두개의 구문이 합쳐진거라고 우선 이해 할 것


③받아올때 sc.next();
스캐너가 가진 가장 큰 특징은 토큰형식으로 받아옴
입력 받아온 것을 기본적으로 "문자열"로 반환함.

Scanner와 BufferedReader차이점

BufferedReader를 쓰는 과정에선 외부로부터 데이터를 입력받아올때 
자바 눈치를 보기때문에 throws IOException을 해줬는데
Scanner는 내부적으로 처리가 돼있기 때문에  IOException안해줘도 됨


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

csv
데이터1, 데이터2, 데이터3


sc = new Scanner(sc.next()).useDelimiter("\\s*,\\s*");

String temp = sc.next();
sc = new Scanner(temp).useDelimiter("\\s*,\\s*");
이 두줄이 위의 한줄임

얻어온 것 "고연수,90,80,70"
new Scanner("고연수,90,80,70").useDelimiter("\\s*,\\s*");
										.구분자 사용()



		sc = new Scanner(sc.next()).useDelimiter("\\s*,\\s*");
		//				---------------
		//				"고연수,90,80,70" 
		//
		//	new Scanner("고연수,90,80,70").useDelimiter("\\s*,\\s*");
		//					-----------------
		//							문자열 		.구분자사용();
		//-------------------------------
		//			스캐너타입
		// ★스캐너타입이라면 스캐너타입의 메서드를 사용할 수 있는 것★(이후 객체지향에서 자세히 다룸)
		//
		//											.useDelimiter("\\s*,\\s*");
		//
		//																"\s*,\s*"
		//																-----
		//														임의의 모든 문자열,임의의 모든 문자열
		//
		//											임의의 모든 문자열과 임의의 모든 문자열사이에 『,』로 구분해줘
		//													(『,』기준으로 자르겠다!)						  				

		Scanner sc = new Scanner("문자열");
		sc.next();
		sc.nextInt();
		sc.nextDouble();
		

public class Scanner
{
		...
		...
		next();
		...		
	
		nextInt();
		nextDouble();
}




ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
import구문 추가 설명

함수() → 메소드() →기능,행위,동작 →일을 시키기 위함
{
	강원도.횡성.보경()
	강원도.횡성.보경()
	강원도.횡성.보경()
	강원도.횡성.보경()
} 
이렇게 하던걸
import구문 쓰게되면
		↓
import.강원도.횡성.보경;
메소드()
{
	보경...
	보경...
	보경...
}

		↓
중복 구문이 되버리면
import 강원도.횡성.보경;
import 제주도.서귀포.보경;
메소드()
{
	보경...
	보경...

} //이런식으로는 사용할 수없음 중복되기 때문임

		↓
중복 구문이 되버리면
메소드()
{
	강원도.횡성.보경...
	제주도.서귀포.보경...
	제주도.서귀포.보경...
	강원도.횡성.보경...

} 
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
throw 일부러 발생시킬때
throws


import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
--==>> import java.io.*; //모두다 찾아봐라

그러나
import java.io.*보다 위의 방식을 권장
사람입장에선 한줄이지만 자바 입장에선 더 많이 찾아보게 됨
내부적으로 봤을때 java가 io안의 모든걸 찾아보기 때문에, 메모리를 조금이라도 더 쓰게됨


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
System.out.printf(%d %% %d = %d%n", num1, num2, res5); 


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
비트단위 연산자
값을 바꾸기 위한 temp(임시 저장 변수)대신 『xor』활용

※ 어떤 값이든 바뀜

		x = x ^ y;
		y = y ^ x;
		x = x ^ y;
	
		y = y ^ x;
		x = x ^ y;
		y = y ^ x;
shift 연산자

00000000 00000000 00000000 10000000   128

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
조건 연산자 == 삼항 연산자

				┌──────┐
	피연산자 연산자 피연산자 연산자 피연산자
	--------		-------		   --------
		1항			  2항			  3항

	피연산자 ? 피연산자 : 피연산자
	--------   -------	 --------
		1항	     2항			3항

	1항의 연산 결과	→ true		→ 2항 수행(치환)
						→ false		→ 3항 수행(치환)

		//홀수인지 짝수인지에 대한 판별 연산
		//_______ ? _________ : _________
		// 수식1		  수식2		  수식3 	
		
		// 수식1: 참(true) 또는 거짓(false)을 반환할 수 있는 수식 형태로 작성
		// 수식1은 참또는 거짓이 반환해야하니 관계연산자 사용

		// 수식2: 수식1의 처리 결과가 참(true)일 경우 수행하는 영역
		// 수식3: 수식1의 처리 결과가 거짓(false)일 경우 수행하는 영역

		// 입력받은 정수(n)가 홀수인지 짝수인지 확인하기 위한 연산
		// → n을 2로 나누어서 나머지가 0이면			→ 짝수
		//							   0이 아니면	→ 홀수
