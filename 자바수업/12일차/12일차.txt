객체 지향 프로그래밍에선
커다란 클래스 보다
작은 클래스들의 조합이 훨씬 위력적



자바
오라클
JDBC


웹클라이언트파트
HTML
CSS
자바스크립트

웹서버 파트
JSP,서블릿




스프링,myBatis,.....


★분리하는게 핵심★




★★★★Test073★★★★★★
class의 멤버변수는 필요하지 않은 것은 굳이 가지고 있을 필요 없음
왜냐하면 속성이라는 변수를 가지고 있으려면 메모리를 차지하는거라고 봐야함
그러므로 항상 주요 변수에 유의 할 것
ex)직사각형 클래스에서 가로 세로만 주어지면 메소드를 통해서 넓이 둘레를 구하고 반환하면
	되는데 굳이 넓이와 둘레를 변수로 가져서 메모리에 할당할 필요가 없음

클래스
//주요변수 선언
메소드()
{
 //여기다 주요변수 선언해도 되지만 밑의 메소드에서 보이지 않으므로
 // 위의 전역변수 자리에 선언을 했음
}
메소드()
{
}
직사각형 test1 = new 직사각형();

메모리에 퍼올린다는 설명을 받았지만, 이건 사실 거짓말임
추후에 배우게 될 것 - 알게되면 수정 할 것 -




ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
★★★★Test074★★★★★★

생성자 활용해서 실습한거 코드 보고 복습 할 것



ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
사용자 정의 생성자가 뭘까???


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
변수와 메소드의 첫번째 역할
★변수와 메소드는 식별자의 역할을 가장 많이 함★
기본적으로 같은 이름의 변수는 다시 선언 못함


★★★★★★★★★★★but 메소드의 오버로딩★★★★★★★★★★★★★
이름이 같은 메소드는 Test076() / Test076(int num)
매개변수의 갯수나 타입이 다르다면 식별이 가능하기에
메소드의 이름이 같아도 정의 할 수있게 함


생성자도 특별한 취급을 받는 메소드라고 이해하고 접근할 것임
생성자도 정체성이 메소드이기때문에 매개변수의 갯수나 타입이 
다르다면 이름을 똑같이 만들 수 있음
(그러나 매개변수를 살펴봐야함)
눈여겨 볼것★
	int x;
	Test076()
	{
		System.out.println("인자 없는 생성자");
	}
	
	//Test076(int num) //Test076() /Test076()은 안됨 Test076()/Test076(int num)
	Test076(int x)
	{
		x = x;			//★식별해낼 수 있기때문에 ok★
						// why?
						//둘 다 지역변수x

		this.x =x;
		System.out.println("인자가 하나인 생성자");
	}


	Test076(int num)
	{
		this.x = num;
			x =num;		//다 가능이지만 보통 매개변수를 int x로쓸것임
	}

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
	//Test076(int num) //Test076() /Test076()은 안됨 Test076()/Test076(int num)
	Test076(int x)
	{	
		//x = num;
		//x = x;				// 둘 다 지역변수 x임 틀린 것임 ????이게 무슨말일까????????
		
		//『this』키워드
		// Test076.x= x; 문법적으로 선점했기때문에 이구문을 못쓰고 this.으로써야함
		//Test076.x =x; 논리적인 해석
		this.x=x;
		//★★this를 보게되면 이게 포함되어있는 클래스를 찾을 것★★★★★★★★★★


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
생성자에서 생성자를 호출하는게 가능하겠냐?
★Test076() 에서 Test076(int x) 생성자 호출 가능?★
생성자 내부에서 다른 생성자를 호출하는 것은 가능하다
//////////////////////////////////////////////////////////////이해방법 ① 메소드에서 메소드끼리 호출하는 것은 가능하니 이렇게 기억		  
하지만, 생성자 내부에서 가장 먼저 실행되어야 한다. check~!!!!
처음에 설정하고 생성자 호출해오면 의미 없는 행위가 되기 때문에.
생성자 먼저 호출해서 초기화 하고
해당 값만 수정하면 그 값만 수정이 가능하기에.	


생성자 이해돕기 위한 예

class 사과장수
{
	int 사과의가격;
	int 사과의갯수;
	int 가진돈;
	
	/*사용자 정의의 생성자를 생성했기에 디폴트 생성자 생성하지 않음
	사과장수()
	{							→그렇다는건  사과장수 ob1 = new 사과장수(); 이렇게 할수 없음 내부에서 하지 않았기때문에?
	}								외부에서 했기 때문인가?
	*/							→사과장수 ob1 = new 사과장수(400, 20, 2000);

	//생성자1
	사과장수(int 가격)
	{
		사과의가격 = 가격;

		//생성자 내부에서 또다른 생성자 호출 구문 → 1이 2를...
		사과장수(400, 20, 10000);
	}

	//생성자2
	사과장수(int 가격, int 갯수, int 돈)			//클래스와똑같은 이름의 생성자
	{
		사과의가격 = 가격;
		사과의갯수 = 갯수;
		가진돈 = 돈;
	}

	//생성자3 
	사과장수()
	{			
		사과의갯수 = 50;			
	}

}

생성자에서 생성자를 호출할 수 있게 해두면
편의성을 위해서 호출이 가능하다
(30개를 초기화 해주는데 모든것을 30개를 초기화 할필요가있나?)


Test076 ob1 = new Test076(); 여기서
Test076()의 this(100);을 먼저 호출해오기에 Test076(int x)일루가서 값100넣고
//인자가 하나인 생성자	
//Test076이 갖고있는 x : 100
이 값이 먼저 출력되고
그다음에 x = 10;을 넣고 Test076()을 수행하는건가요?



ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
클래스의 영역
메소드의 영역

★초기화 블럭
특별하지 않은 범용적인 속성을 설정 하는데 많이 사용,이유는 생성자가 파워가 세기때문에 생성자 불러오면 다시 초기화 되기 때문임